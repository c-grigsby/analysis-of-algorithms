Recurrence Formula
   
           0                                   if i <= 0
     
f(n, i) =  n[i-1]                              if i = 1

           max{ n[i-1] + f(i-2), n[i-2] + f(i-3), n(i-1), n(i-2) }      if i > 1

Where i equals the length of the array, and n is the array of integers

(The off by one thing is weird I know. I played around with this a bit in the main algorithm. Why so many cases right? I found out the negative numbers will come into play.)


Pseudocode: Brute Force Approach (To make sure the recurrence formula works)

max_subsequence_BF(numArr, i)
  if i <= 0, then return 0
  if i == 1: then return numArr[i-1]
  
  return max(numArr[i-1] + max_subsequence_BF(numArr, i-2), numArr[i-2] + max_subsequence_BF(numArr, i-3), numArr[i-1], numArr[i-2])
    
Pseudocode: Bottom-up

max_independent_set(numArr)

  arr_length = len(numArr)
  if arr_length == 0 or arr_length == 1, then return numArr
  cache=[0 for i in range(arr_length)]
  solution = []
  
  # base cases for cache
  if arr_length >= 1, then cache[0] = numArr[0]
  if arr_length >= 2, then cache[1] = max(numArr[0], numArr[1])
    
  # obtain the max total from the cache (here this took a little white boarding for the i positions as we are moving forward now)
  for i in range(2, arr_length)
    cache[i] = max(numArr[i] + cache[i-2], cache[i-1], numArr[i], cache[i-2])
  maxTotal = cache[arr_length-1]
  
  # if maxTotal is less than or equal to zero 
  if maxTotal < 0, then return []
  elif maxTotal == 0, then return [0]
  
  # use the recurrence equation and maxTotal to iterate back for the values
  currentTotal = maxTotal
  i = arr_length-1
  while i >= 0 and currentTotal > 0: 

    #case 1
    if numArr[i] + cache[i-2] == currentTotal:
      solution.append(numArr[i])
      currentTotal -= numArr[i]
      i -= 2

    #case 2
    else if numArr[i-1] + cache[i-3] == currentTotal:
      solution.append(numArr[i-1])
      currentTotal -= numArr[i-1]
      i -= 3

    # case 3
    else if numArr[i] == currentTotal:
      solution.append(numArr[i])
      currentTotal -= numArr[i]
      i -= 1

    # case 4
    else if numArr[i-1] == currentTotal:
      solution.append(numArr[i-1])
      currentTotal -= numArr[i-1]
      i -= 1

    # return error
    else:
      return solution.append("Error")
  
  # reverse the solution array and return
  solution.reverse()
  return solution

 
# driver
numbers1 = [7, 2, 5, 8, 6]
numbers2 = [-1, -1, 0]
numbers3 = [-1, -1, -10, -34]
result = max_independent_set(numbers1)
print("Max subsequence of non-consecutive numbers:", result)
